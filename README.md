# 📈 BLISS Analytics

Business Language Interface for Self-Serve Analytics

A proof-of-concept (PoC) tool that lets business users ask questions in plain English and instantly get SQL queries and results — powered by an LLM and a lightweight rule engine.

---

## ✅ What This Does

- Translates natural language questions into SQL using:
  - 🤖 A local LLM (Mistral via Ollama)
  - 🧠 A rule-based SQL generator
- Provides context from:
  - ERD (YAML format)
  - Business glossary (CSV with table/column mapping + synonyms)
  - Optional schema metadata
- Displays matched business terms
- 📘 Exposes glossary in UI (inline and full view)
- Lets users compare LLM and rule-based SQL outputs
- Supports query execution, previews, and CSV export (coming soon)

---

## 📐 Design Principles

These principles guide the architecture and evolution of BLISS:

| Principle                  | Description                                                                 |
|---------------------------|-----------------------------------------------------------------------------|
| 📦 Modularity             | Each component (LLM, rule engine, glossary, schema) is swappable and isolated. |
| 📊 Metadata-First Design  | ERD and glossary are first-class citizens — not just documentation.          |
| 🧠 Human-Centered UX      | Designed for clarity — users can inspect SQL, glossary terms, and context.   |
| 🔁 Feedback-Friendly      | System is designed to evolve via user feedback and glossary edits.           |
| 🔐 Separation of Concerns | Frontend, backend, and LLM logic are separated for scalability and clarity.  |
| 🧩 Extensibility           | Supports new domains by simply swapping ERD + glossary files.                |

---

## 🧱 Architecture Overview

| Layer                | Status | Highlights |
|---------------------|--------|------------|
| Metadata Loader     | ✅     | Loads YAML + CSV metadata cleanly |
| LLM Prompt Adapter  | ✅     | Structured prompt creation with glossary/ERD |
| Rule Engine         | ✅     | ERD-based keyword matching for basic SQL |
| Controller          | ✅     | Routes question through both engines |
| SQL Execution       | 🔲     | DuckDB-based engine stubbed, backend wiring WIP |
| Output Visualization| 🔲     | Charting & CSV download planned |
| UI (Streamlit)      | ✅     | Clean UX with toggles, term highlighting |

---

## 🧩 Current Capabilities

- Ask business questions in plain English
- See SQL generated by:
  - 🤖 LLM (via formatted prompt)
  - 🧠 Rule engine (fallback logic)
- View matched business glossary terms
- Browse full glossary in sidebar
- Easily toggle dev/debug views
- Preview prompt inputs and matched metadata
- Modular architecture for backend/frontend

---

## 🛠️ Roadmap

### 🎯 Short-Term Goals

| Area     | Status | Goal |
|----------|--------|------|
| Backend  | ✅     | Run SQL on DuckDB backend |
| Backend  | 🔲     | Add SQL validation & formatting (e.g., via sqlglot) |
| Frontend | 🔲     | Display tabular results from backend |
| Frontend | ✅     | Show matched glossary terms in UI |
| Frontend | ✅     | Add glossary toggle (full glossary + inline) |
| Frontend | 🔲     | Add feedback loop (flag incorrect SQL) |

### 📊 Output Features (Planned)

| Feature         | Benefit |
|----------------|---------|
| 📈 Visual Charts | Plot results for quick insights |
| 📁 CSV Download | Export results easily |
| 🧠 Term Tracing | Map glossary terms → SQL columns |

### ☁️ Cloud & Production Readiness (Optional)

This PoC is modular by design and can be extended to real-world production environments.

| Area              | Goal / Adaptation                                                                 |
|-------------------|-----------------------------------------------------------------------------------|
| 📦 Warehouse Support| Plug into Amazon Redshift, BigQuery, or Snowflake with connector module.         |
| 🔐 User Access     | Integrate user auth (e.g., company SSO) to restrict query access or schemas.     |
| 🧩 Metric Layer     | Optionally integrate DBT or other semantic layers to define reusable metrics.     |
| 🧠 Fine-Tuning      | Use stored feedback (user corrections) to improve prompts or finetune models.     |
| 🧪 Evaluation Tools | Add observability: log matched terms, SQL validity, latency, feedback status.    |

---

## 📁 File Structure

```
bliss-sanssql-poc/
│
├── backend/
│   ├── main.py              # FastAPI app
│   ├── controller.py        # Orchestrates LLM + rule engine
│   ├── llm_adapter.py       # Formats prompt, calls LLM
│   ├── rule_engine.py       # Basic SQL generation from ERD
│   ├── metadata_loader.py   # Loads ERD, glossary, metadata
│   ├── run_sql.py           # Executes SQL via DuckDB
│
├── metadata/
│   ├── erd.yaml             # Tables, columns, joins
│   ├── glossary.csv         # Business terms → table.column
│   └── schema_metadata.yaml # (Optional) Descriptions per column
│
├── frontend/
│   └── streamlit_app.py     # Streamlit UI
│
├── data/
│   ├── dim_campaign.csv
│   ├── dim_customer.csv
│   ├── fact_message_event.csv
│   └── marketing.db         # DuckDB database
```

---

## 🚀 Getting Started

```bash
# 1. Start backend
cd backend
uvicorn main:app --reload

# 2. Run frontend
cd ../frontend
streamlit run streamlit_app.py
```

---

## 🙌 Credits & Notes

- Built by Ram with ChatGPT as a thinking and engineering partner 💬
- Mistral runs locally via Ollama for fast LLM inference
- Designed to be modular and beginner-friendly
- Best used as a template for more vertical-specific self-serve analytics tools

---

## ✅ Status: Working Prototype

This PoC is functional for generating SQL queries from natural language. Backend query execution has been scaffolded and is partially working. Frontend output preview and export features are up next!
